final
 -変数、メソッド、クラスの前につけることにより、後に値の変換や継承をできないように出来る
　　ーfinal double tax = 0.1   ---X--->  tax = 0.5
　　
    -final void attak(){                                       void attak(){
             System.out.println("手で攻撃する");   ---X--->            System.out.println("手で攻撃する");
　　　　　　　　　　　　}                                                        }
　　　　　　　　　　　　
　　-final class oya {                                          class oya extends kodomo{
　　                                              ---X--->
　　             }                                                                   }
class Main{
    public static void main(String[] args){
        //【問題】円の面積を求めるプログラムを作成してみましょう。

        //★円周率を持たせるfinal修飾子を付けたdouble型の変数「pi」を初期値3.14で宣言してみましょう。★
        final double pi = 3.14;

        //円の半径を持たせるdouble型の変数「radius」を初期値5で宣言します。
        double radius = 5;

        //円の面積を持たせるdouble型の変数「area」を初期値０で宣言してみましょう。
        double area = 0;

        //★円の面積を「pi」「radius」を用いて求めて変数「area」に代入してみましょう。
        //ただし、円の面積は半径×半径×円周率で求められます。★
        area = radius * radius * pi;

        //円の面積を表示します。
        System.out.println(area);

        //実行して確認したら、radiusの値を0~10までの間で変更して試してみましょう。
    }
}



static 


class Main {
	public static void main(String[] args) {
		//【問題】以下のプログラムが正しく実行されるようにstaticを付けてみましょう。

		//String型の変数「answer」を宣言し、双子葉類を初期値として与えます。
		String answer = "双子葉類";

		//「Result」クラスをインスタンス化します。ただし、インスタンス名を「result」とします。
		Result result = new Result();

		//今回はアサガオの問題を想定してみます。
		//★「answer」が双子葉類と等しいかを判別できるように以下のif文を埋めてみましょう★
		if(answer.equals("双子葉類")) {
			System.out.println(Result.correct);
		}else {
			System.out.println(result.incorrect);
		}

	}
}

class Result {
	//★mainメソッドが正しく実行されるように、「correct」「incorrect」どちらか一方にだけstaticを書き加えてみましょう。
	static String correct = "正解";
	String incorrect = "不正解";
}



try~catch　　　　　　　　　　　　　　　　　　　　　　　　　 通常な処理を行っている途中で➀(今回の場合は繰り返し文の場合)　
基本構文  try{                                              例外な処理が起きた場合本来であればエラーが起きてしまうが
            int kotae = a / b;　　　　　　　　　　　　　　　事前にこのエラーが起きた時➁はこの処理をするとしておけば
             }catch(0で割ってしまうという例外){➁　　　　　　 エラーが起きた時システムエラーでなく、その処理の内容➂を実行することができる
               System.out.println("0では割れません");➂
                  }

class Main {
	public static void main(String[] args) {
		//	【問題】解答を配列に格納し、表示させようとしたときに発生する可能性のある例外を考えてみましょう。

		//	問題数を表すint型の変数「question」を宣言し、4を代入します。
		int question = 4;

		//	問題の解答をString型の配列「answer」に代入します。
		//	ただし、今回は例外を確認するため最初の三問のみ格納します。
		String[] answer = {"太宰治","谷崎潤一郎","川端康成"};

		//	例外が発生する可能性がある処理を行います。
		try {                                                                                  -----
                                                                                                    |
			//★問題数分処理を繰り返すように以下のfor文を正しく埋めてみましょう。                   | 
			//	ただし、カウンタ変数をiとし、初期値を0、変数「question」より小さいとします。★      |
			for(int i = 0;i<question;i++) {                                                         |  ➀
                                                                                                    |
				//	配列「answer」からインデックス番号がiの要素を表示します。                       |
				System.out.println(answer[i]);                                                      |
			}                                                                                  -----
			//★この処理では、配列の要素数より多く繰り返しているため
			//「ArrayIndexOutOfBoundsException」という例外が発生します。
			//キャッチできるように以下の空欄を埋めてみましょう
			//ただし引数は「eとします」★
		}catch(ArrayIndexOutOfBoundsException e) {    ➁
			System.out.println("例外が発生しました。");      ➂
		}
	}
}


class Main {
	public static void main(String[] args) {
		//	【問題】足し算・引き算・掛け算・割り算がそれぞれ０で実行できるか確認してみましょう。
		//			例で与えられた足し算と同じように、他の演算についても記述してみましょう。

		int i = 3;
		int result = 0;

		//	例）足し算
		try {
			//iと0を足し算して式と結果を出力しましょう。
			System.out.print(i + "+0=");
			result = i + 0;
			System.out.println(result);
		}catch(Exception e){
			//例外をキャッチした時は「実行できません」を表示しましょう。
			System.out.println("実行できません");
		}

		//	上記の例を参考に、他の演算についても記述してみましょう。
		//	コメント部分は書かなくてよいです。
		//★①引き算★
        try {
			System.out.print(i + "-0=");
			result = i - 0;
			System.out.println(result);
		}catch(Exception e){
			System.out.println("実行できません");
		}

		//★②掛け算★
        try {
			System.out.print(i + "*0=");
			result = i * 0;
			System.out.println(result);
		}catch(Exception e){
			System.out.println("実行できません");
		}

		//★③割り算★
        try {
			System.out.print(i + "/0=");
			result = i / 0;
			System.out.println(result);
		}catch(Exception e){
			System.out.println("実行できません");
		}

	}
}


class Main {

	public static void main(String[] args) {

		//【問題】20個の飴を入力された人数で分ける処理を行うとき、
		//人数に0人が入力された場合に例外処理を行うようプログラムを完成させましょう。

		//入力された人数をint型の変数numに入れて初期化します。
		int num = 0;

		//0除算が発生する可能性のある処理をtry内に記述します。
		//★tryで処理を囲ってみましょう。★
	 try{
			//int型の変数shoに飴の数20を変数numで割った結果を代入します。
			int sho = 20 / num;
			//★int型の変数amariに20を変数numで割った余りを代入してみましょう。★
            int amari = 20 % num;

			//変数shoとamariを出力します。
			System.out.println(sho);
			System.out.println(amari);

		//0除算が行われたときに、例外(ArithmeticException)を受け取り、catch内の処理が実行されます。
		//★catchを記述してみましょう。★
		}catch(Exception ex){
			//例外が発生した場合"0除算です。"を出力します。
			System.out.println("0除算です。");
		}
	}
}



起動引数


class Main {
	public static void main(String[] args) {
		//	【問題】起動引数に指定された月の昔の呼び方と、その由来を表示するプログラムを作成してみましょう。

		//★String型の「month」を宣言し、起動引数の先頭の要素を代入しましょう。★
		String month = "2";

		//	「month」の値によって実行する処理を変えるためにswitch文を使用します。
		//★以下の空欄を正しく埋めてみましょう。★
		switch(month) {
		//	1の場合
		case "1":
			System.out.println("睦月");
			System.out.println("正月に当たって親しみ睦み合って交誼を暖めるということからきた。");
			break;
			//	2の場合
		case "2":
			System.out.println("如月");
			System.out.println("寒くて更にきぬを着る、衣更着（きぬさらぎ）からきたという。");
			break;
			//	3の場合
		case "3":
			System.out.println("弥生");
			System.out.println("「草木弥生月」を略した言葉。「弥」は「いよいよ」「ますます」という意味があり、草木がいよいよ生い茂るという意味の「弥生」が変化した呼び名");
			break;
			//	4の場合
		case "4":
			System.out.println("卯月");
			System.out.println("ユキノシタ科の落葉低木「ウヅキ」の花である「卯の花」が咲くころの意味");
			break;
			//	5の場合
		case "5":
			System.out.println("皐月");
			System.out.println("田植えが始まる時期なので、「早苗を植える月」という意味から「早苗月」と呼ばれ、それが略されて「さつき」になったといわれている");
			break;
			//	6の場合
		case "6":
			System.out.println("水無月");
			System.out.println("旧暦では梅雨明けの残暑の頃となり、厳しい日照りが続いて水が枯れる月ということから「水無月」となった。");
			break;
			//	７の場合
		case "7":
			System.out.println("文月");
			System.out.println("短冊に歌や字を書く七夕の行事から「文披月（ふみひろげづき）」、稲穂が膨らむ月ということで「ふくみ月」、これらが転じて「文月」になったといわれている。");
			break;
        case "8":
			System.out.println("葉月");
			System.out.println("葉の落ちる月「葉落月（はおちづき）」が転じて「葉月」。現代感覚では葉が生い茂る様子を思い浮かべるが、旧暦では7月から秋となるため、秋真っ盛りだった。");
			break;
		case "9":
			System.out.println("長月");
			System.out.println("秋の夜長を意味する「夜長月（よながづき）」の略で「長月」になった。また、秋の長雨の「長雨月（ながめづき）」、稲穂が実る「穂長月（ほながづき）」からという説も。");
			break;
		case "10":
			System.out.println("神無月");
			System.out.println("神々が出雲の国に行ってしまい留守になるという意の「神なき月」が転訛して「神無月」。神々が集まる出雲の国では、「神在月（かみありつき）」という。");
			break;
		case "11":
			System.out.println("霜月");
			System.out.println("文字通り霜が降る月という意の「霜降月（しもふりつき）」の略で「霜月」となった。");
			break;
		case "12":
			System.out.println("師走");
			System.out.println("12月は僧（師）を迎えてお経を読んでもらう月だった。師が馳せる月という意の「師馳す」が転訛し、走るという字があてられるようになった。");
			break;	
		}

		//★起動引数に「1」～「12」までの好きな数字を指定して実行してみましょう。★
	}
}
