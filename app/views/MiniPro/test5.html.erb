final
 -変数、メソッド、クラスの前につけることにより、後に値の変換や継承をできないように出来る
　　ーfinal double tax = 0.1   ---X--->  tax = 0.5
　　
    -final void attak(){                                       void attak(){
             System.out.println("手で攻撃する");   ---X--->            System.out.println("手で攻撃する");
　　　　　　　　　　　　}                                                        }
　　　　　　　　　　　　
　　-final class oya {                                          class oya extends kodomo{
　　                                              ---X--->
　　             }                                                                   }
class Main{
    public static void main(String[] args){
        //【問題】円の面積を求めるプログラムを作成してみましょう。

        //★円周率を持たせるfinal修飾子を付けたdouble型の変数「pi」を初期値3.14で宣言してみましょう。★
        final double pi = 3.14;

        //円の半径を持たせるdouble型の変数「radius」を初期値5で宣言します。
        double radius = 5;

        //円の面積を持たせるdouble型の変数「area」を初期値０で宣言してみましょう。
        double area = 0;

        //★円の面積を「pi」「radius」を用いて求めて変数「area」に代入してみましょう。
        //ただし、円の面積は半径×半径×円周率で求められます。★
        area = radius * radius * pi;

        //円の面積を表示します。
        System.out.println(area);

        //実行して確認したら、radiusの値を0~10までの間で変更して試してみましょう。
    }
}



static 


class Main {
	public static void main(String[] args) {
		//【問題】以下のプログラムが正しく実行されるようにstaticを付けてみましょう。

		//String型の変数「answer」を宣言し、双子葉類を初期値として与えます。
		String answer = "双子葉類";

		//「Result」クラスをインスタンス化します。ただし、インスタンス名を「result」とします。
		Result result = new Result();

		//今回はアサガオの問題を想定してみます。
		//★「answer」が双子葉類と等しいかを判別できるように以下のif文を埋めてみましょう★
		if(answer.equals("双子葉類")) {
			System.out.println(Result.correct);
		}else {
			System.out.println(result.incorrect);
		}

	}
}

class Result {
	//★mainメソッドが正しく実行されるように、「correct」「incorrect」どちらか一方にだけstaticを書き加えてみましょう。
	static String correct = "正解";
	String incorrect = "不正解";
}



try~catch　　　　　　　　　　　　　　　　　　　　　　　　　 通常な処理を行っている途中で➀(今回の場合は繰り返し文の場合)　
基本構文  try{                                              例外な処理が起きた場合本来であればエラーが起きてしまうが
            int kotae = a / b;　　　　　　　　　　　　　　　事前にこのエラーが起きた時➁はこの処理をするとしておけば
             }catch(0で割ってしまうという例外){➁　　　　　　 エラーが起きた時システムエラーでなく、その処理の内容➂を実行することができる
               System.out.println("0では割れません");➂
                  }

class Main {
	public static void main(String[] args) {
		//	【問題】解答を配列に格納し、表示させようとしたときに発生する可能性のある例外を考えてみましょう。

		//	問題数を表すint型の変数「question」を宣言し、4を代入します。
		int question = 4;

		//	問題の解答をString型の配列「answer」に代入します。
		//	ただし、今回は例外を確認するため最初の三問のみ格納します。
		String[] answer = {"太宰治","谷崎潤一郎","川端康成"};

		//	例外が発生する可能性がある処理を行います。
		try {

			//★問題数分処理を繰り返すように以下のfor文を正しく埋めてみましょう。
			//	ただし、カウンタ変数をiとし、初期値を0、変数「question」より小さいとします。★
			for(int i = 0;i<question;i++) {

				//	配列「answer」からインデックス番号がiの要素を表示します。
				System.out.println(answer[i]);
			}
			//★この処理では、配列の要素数より多く繰り返しているため
			//「ArrayIndexOutOfBoundsException」という例外が発生します。
			//キャッチできるように以下の空欄を埋めてみましょう
			//ただし引数は「eとします」★
		}catch(ArrayIndexOutOfBoundsException e) {
			System.out.println("例外が発生しました。");
		}
	}
}
