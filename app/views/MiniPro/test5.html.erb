final
 -変数、メソッド、クラスの前につけることにより、後に値の変換や継承をできないように出来る
　　ーfinal double tax = 0.1   ---X--->  tax = 0.5
　　
    -final void attak(){                                       void attak(){
             System.out.println("手で攻撃する");   ---X--->            System.out.println("手で攻撃する");
　　　　　　　　　　　　}                                                        }
　　　　　　　　　　　　
　　-final class oya {                                          class oya extends kodomo{
　　                                              ---X--->
　　             }                                                                   }
class Main{
    public static void main(String[] args){
        //【問題】円の面積を求めるプログラムを作成してみましょう。

        //★円周率を持たせるfinal修飾子を付けたdouble型の変数「pi」を初期値3.14で宣言してみましょう。★
        final double pi = 3.14;

        //円の半径を持たせるdouble型の変数「radius」を初期値5で宣言します。
        double radius = 5;

        //円の面積を持たせるdouble型の変数「area」を初期値０で宣言してみましょう。
        double area = 0;

        //★円の面積を「pi」「radius」を用いて求めて変数「area」に代入してみましょう。
        //ただし、円の面積は半径×半径×円周率で求められます。★
        area = radius * radius * pi;

        //円の面積を表示します。
        System.out.println(area);

        //実行して確認したら、radiusの値を0~10までの間で変更して試してみましょう。
    }
}



static 


class Main {
	public static void main(String[] args) {
		//【問題】以下のプログラムが正しく実行されるようにstaticを付けてみましょう。

		//String型の変数「answer」を宣言し、双子葉類を初期値として与えます。
		String answer = "双子葉類";

		//「Result」クラスをインスタンス化します。ただし、インスタンス名を「result」とします。
		Result result = new Result();

		//今回はアサガオの問題を想定してみます。
		//★「answer」が双子葉類と等しいかを判別できるように以下のif文を埋めてみましょう★
		if(answer.equals("双子葉類")) {
			System.out.println(Result.correct);
		}else {
			System.out.println(result.incorrect);
		}

	}
}

class Result {
	//★mainメソッドが正しく実行されるように、「correct」「incorrect」どちらか一方にだけstaticを書き加えてみましょう。
	static String correct = "正解";
	String incorrect = "不正解";
}



try~catch　　　　　　　　　　　　　　　　　　　　　　　　　 通常な処理を行っている途中で➀(今回の場合は繰り返し文の場合)　
基本構文  try{                                              例外な処理が起きた場合本来であればエラーが起きてしまうが
            int kotae = a / b;　　　　　　　　　　　　　　　事前にこのエラーが起きた時➁はこの処理をするとしておけば
             }catch(0で割ってしまうという例外){➁　　　　　　 エラーが起きた時システムエラーでなく、その処理の内容➂を実行することができる
               System.out.println("0では割れません");➂
                  }

class Main {
	public static void main(String[] args) {
		//	【問題】解答を配列に格納し、表示させようとしたときに発生する可能性のある例外を考えてみましょう。

		//	問題数を表すint型の変数「question」を宣言し、4を代入します。
		int question = 4;

		//	問題の解答をString型の配列「answer」に代入します。
		//	ただし、今回は例外を確認するため最初の三問のみ格納します。
		String[] answer = {"太宰治","谷崎潤一郎","川端康成"};

		//	例外が発生する可能性がある処理を行います。
		try {                                                                                  -----
                                                                                                    |
			//★問題数分処理を繰り返すように以下のfor文を正しく埋めてみましょう。                   | 
			//	ただし、カウンタ変数をiとし、初期値を0、変数「question」より小さいとします。★      |
			for(int i = 0;i<question;i++) {                                                         |  ➀
                                                                                                    |
				//	配列「answer」からインデックス番号がiの要素を表示します。                       |
				System.out.println(answer[i]);                                                      |
			}                                                                                  -----
			//★この処理では、配列の要素数より多く繰り返しているため
			//「ArrayIndexOutOfBoundsException」という例外が発生します。
			//キャッチできるように以下の空欄を埋めてみましょう
			//ただし引数は「eとします」★
		}catch(ArrayIndexOutOfBoundsException e) {    ➁
			System.out.println("例外が発生しました。");      ➂
		}
	}
}


class Main {
	public static void main(String[] args) {
		//	【問題】足し算・引き算・掛け算・割り算がそれぞれ０で実行できるか確認してみましょう。
		//			例で与えられた足し算と同じように、他の演算についても記述してみましょう。

		int i = 3;
		int result = 0;

		//	例）足し算
		try {
			//iと0を足し算して式と結果を出力しましょう。
			System.out.print(i + "+0=");
			result = i + 0;
			System.out.println(result);
		}catch(Exception e){
			//例外をキャッチした時は「実行できません」を表示しましょう。
			System.out.println("実行できません");
		}

		//	上記の例を参考に、他の演算についても記述してみましょう。
		//	コメント部分は書かなくてよいです。
		//★①引き算★
        try {
			System.out.print(i + "-0=");
			result = i - 0;
			System.out.println(result);
		}catch(Exception e){
			System.out.println("実行できません");
		}

		//★②掛け算★
        try {
			System.out.print(i + "*0=");
			result = i * 0;
			System.out.println(result);
		}catch(Exception e){
			System.out.println("実行できません");
		}

		//★③割り算★
        try {
			System.out.print(i + "/0=");
			result = i / 0;
			System.out.println(result);
		}catch(Exception e){
			System.out.println("実行できません");
		}

	}
}


class Main {

	public static void main(String[] args) {

		//【問題】20個の飴を入力された人数で分ける処理を行うとき、
		//人数に0人が入力された場合に例外処理を行うようプログラムを完成させましょう。

		//入力された人数をint型の変数numに入れて初期化します。
		int num = 0;

		//0除算が発生する可能性のある処理をtry内に記述します。
		//★tryで処理を囲ってみましょう。★
	 try{
			//int型の変数shoに飴の数20を変数numで割った結果を代入します。
			int sho = 20 / num;
			//★int型の変数amariに20を変数numで割った余りを代入してみましょう。★
            int amari = 20 % num;

			//変数shoとamariを出力します。
			System.out.println(sho);
			System.out.println(amari);

		//0除算が行われたときに、例外(ArithmeticException)を受け取り、catch内の処理が実行されます。
		//★catchを記述してみましょう。★
		}catch(Exception ex){
			//例外が発生した場合"0除算です。"を出力します。
			System.out.println("0除算です。");
		}
	}
}



起動引数


class Main {
	public static void main(String[] args) {
		//	【問題】起動引数に指定された月の昔の呼び方と、その由来を表示するプログラムを作成してみましょう。

		//★String型の「month」を宣言し、起動引数の先頭の要素を代入しましょう。★
		String month = "2";

		//	「month」の値によって実行する処理を変えるためにswitch文を使用します。
		//★以下の空欄を正しく埋めてみましょう。★
		switch(month) {
		//	1の場合
		case "1":
			System.out.println("睦月");
			System.out.println("正月に当たって親しみ睦み合って交誼を暖めるということからきた。");
			break;
			//	2の場合
		case "2":
			System.out.println("如月");
			System.out.println("寒くて更にきぬを着る、衣更着（きぬさらぎ）からきたという。");
			break;
			//	3の場合
		case "3":
			System.out.println("弥生");
			System.out.println("「草木弥生月」を略した言葉。「弥」は「いよいよ」「ますます」という意味があり、草木がいよいよ生い茂るという意味の「弥生」が変化した呼び名");
			break;
			//	4の場合
		case "4":
			System.out.println("卯月");
			System.out.println("ユキノシタ科の落葉低木「ウヅキ」の花である「卯の花」が咲くころの意味");
			break;
			//	5の場合
		case "5":
			System.out.println("皐月");
			System.out.println("田植えが始まる時期なので、「早苗を植える月」という意味から「早苗月」と呼ばれ、それが略されて「さつき」になったといわれている");
			break;
			//	6の場合
		case "6":
			System.out.println("水無月");
			System.out.println("旧暦では梅雨明けの残暑の頃となり、厳しい日照りが続いて水が枯れる月ということから「水無月」となった。");
			break;
			//	７の場合
		case "7":
			System.out.println("文月");
			System.out.println("短冊に歌や字を書く七夕の行事から「文披月（ふみひろげづき）」、稲穂が膨らむ月ということで「ふくみ月」、これらが転じて「文月」になったといわれている。");
			break;
        case "8":
			System.out.println("葉月");
			System.out.println("葉の落ちる月「葉落月（はおちづき）」が転じて「葉月」。現代感覚では葉が生い茂る様子を思い浮かべるが、旧暦では7月から秋となるため、秋真っ盛りだった。");
			break;
		case "9":
			System.out.println("長月");
			System.out.println("秋の夜長を意味する「夜長月（よながづき）」の略で「長月」になった。また、秋の長雨の「長雨月（ながめづき）」、稲穂が実る「穂長月（ほながづき）」からという説も。");
			break;
		case "10":
			System.out.println("神無月");
			System.out.println("神々が出雲の国に行ってしまい留守になるという意の「神なき月」が転訛して「神無月」。神々が集まる出雲の国では、「神在月（かみありつき）」という。");
			break;
		case "11":
			System.out.println("霜月");
			System.out.println("文字通り霜が降る月という意の「霜降月（しもふりつき）」の略で「霜月」となった。");
			break;
		case "12":
			System.out.println("師走");
			System.out.println("12月は僧（師）を迎えてお経を読んでもらう月だった。師が馳せる月という意の「師馳す」が転訛し、走るという字があてられるようになった。");
			break;	
		}

		//★起動引数に「1」～「12」までの好きな数字を指定して実行してみましょう。★
	}
}


??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

import java.util.Random;

class Main {
	public static void main(String[] args) {
		//	【問題】起動引数に元素名を入れ、ランダムで指定されたものが何に利用されているかを表示するプログラムを句作ってみましょう。

		//	Randomクラスをインスタンス化します。
		Random random = new Random();

		//	int型の変数「no」にランダムで0~9までを発生させて代入します。
		//★以下の（）に正しい数値を埋めてみましょう。★
		int no = random.nextInt(9);
		//★String型の変数「name」を宣言し、起動引数(no + 1)番目の要素を代入してみましょう。★
		String name = args[no + 1];                                                    //やった事
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　283行目にnoを出力し、randamメソッドが起動しているか確認
		//	選択された元素を表示します。　　　　　　　　　　　　　　　　　　　　　　　　そのため、284行目の代入部分　か　337行目以降のdata部分の不備と想定
		System.out.println(name);
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　284
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 main(args[no]) ereeo
		//	「name」の値によって、実行する処理を分けるためにswitch文を利用します。
		//★以下の空欄を正しく埋めてみましょう。★                                        377
		                                                                                 String[] args = new String[10];
		switch(name) {
		//	水素の場合
		case "水素":
			System.out.println("ロケットの発射");
			break;
			//	ヘリウムの場合
		case "ヘリウム":
			System.out.println("風船");
			break;
			//	リチウムの場合
		case "リチウム":
			System.out.println("リチウムイオン電池");
			break;
			//	ベリリウムの場合
		case "ベリリウム":
			System.out.println("強力なばね");
			break;
			//	ホウ素の場合
		case "ホウ素":
			System.out.println("耐熱ガラス");
			break;
			//★以上の例を参考にして、「炭素」「窒素」「酸素」「フッ素」「ネオン」の場合も書いてみましょう。★
			//	ただしそれぞれの利用例は以下の通りです。
			//	炭素→鉛筆
			//	窒素→肥料
			//	酸素→医療用吸入器
			//	フッ素→歯のコーティング
			//	ネオン→ネオンサイン
		case "炭素":
			System.out.println("鉛筆");
			break;
		case "窒素":
			System.out.println("肥料");
			break;
		case "酸素":
			System.out.println("医療用吸入器");
			break;
		case "フッ素":
			System.out.println("歯のコーティング");
			break;
		case "ネオン":
			System.out.println("ネオンサイン");
			break;	
		}
		//★起動引数に「水素 ヘリウム リチウム ベリリウム ホウ素 炭素 窒素 酸素 フッ素 ネオン」を指定して実行してみましょう。★
		
		
		
	}
}

入力する引数
水素 ヘリウム リチウム ベリリウム ホウ素 炭素 窒素 酸素 フッ素 ネオン
????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

String class


import java.util.Random;

class Main {
	public static void main(String[] args) {
		//	【問題】ことわざの前半を格納する配列と、後半を格納する配列をそれぞれ用意しましょう。
		//	ランダムで要素を一つずつ取り出し、結合して表示してみましょう。

		//前半の配列を作成します。
		String[] first = {"弘法も","かわいい子には","柳に","火のないところに"};

		//続いて後半の配列を作成しましょう。
		String[] latter = {"旅をさせよ","筆の誤り","煙は立たぬ","雪折れなし"};

		Random random = new Random();

		//String型の変数「zenhan」にランダムで配列「first」から取り出した要素を格納します。
		String zenhan = first[random.nextInt(4)];

		//String型の変数「kouhan」にランダムで配列「latter」から取り出した要素を格納します。
		String kouhan = latter[random.nextInt(4)];

		//★String型の変数「result」に「zenhan」と「kouhan」を接合させて代入しましょう。★
		String result = zenhan + kouhan;

		//★「result」を表示してみましょう。★
		System.out.println(result);
	}
}




String型変数.length()
  String型変数内の文字列の数を求めるメソッド(メソッドの為、最後に()を付けなければならない)

class Main {
	public static void main(String[] args) {
		//【問題】上五・中七・下五それぞれの文字数を確認し、字余り・字足らずを判定するプログラムを作成してみましょう。

		//	String型の変数「kami」「naka」「simo」にそれぞれ上五・中七・下五の文字列を格納します。
		String kami = "たびにやんで";
		String naka = "ゆめはかれのを";
		String simo = "かけめぐる";

		//「kami」の文字数が5より多い、または「naka」の文字数が7より多い、または「simo」の文字数が5より多いかどうかを判定し
		//その条件を満たす場合「字余りです」と表示するif文を作成しました。
		if(kami.length() > 5 || naka.length() > 7 || simo.length() > 5) {
			System.out.println("字余りです。");
		}

		//★「kami」の文字数が5より少ない、または「naka」の文字数が7より少ない、または「simo」の文字数が5より少ないかどうかを
		//判定できるように以下のif文を、上記のif文を参考に埋めてみましょう。★
		if(kami.length()<5 || naka.length()<7 || simo.length()<5) {
			System.out.println("字足らずです。");
		}
	}
}



String型変数.charAt()
   文字列の中から指定した1文字(char)を抜き出す際に利用
   順番は配列と同じで0～始まり、文字列の数以上に記載するとエラーになる
   
class Main {
	public static void main(String[] args) {
		//	【問題】用意した多項式の同類項の数を数えるプログラムを作成してみましょう。

		//	まず、変数「numericalExpression」に多項式を用意しました。
		String numericalExpression = "x+2+y+3x+5";

		//	「numericalExpression」にxの項が何回出てくるかを数えてみます。
		//	まず、何回出てきたかカウントするための変数「count」を用意します。
		int count = 0;

		//	比較するための答え「answer」を用意します。
		int answer = 2;

		//★for文を「numericalExpression」の文字数分繰り返すように正しく埋めてみましょう。
		//	ただしカウンタ変数をi、初期値を0として、length()メソッドを利用しましょう。★
		
		for(int i = 0;i < numericalExpression.length();i++) 
		
			//★charAtメソッドを利用して、i文字目が「x」と一致しているかどうか判断できるように以下のif文を埋めてみましょう。★
			if(numericalExpression.charAt(i) == 'x') {　　　　　　　　　　　　　　　　　　　　　　　★charなので''シングルクォーテーションで囲む
			
				//★一致しているのでインクリメント演算子を利用して、countの値を増やしてみましょう。★
                   count++;
			}
		}
		
		
		//	求めた「count」を表示します。
		System.out.print(count + "：");

		//★「count」と「answer」が一致しているか判定できるように以下のif文を埋めてみましょう。★
		if(count == answer) {
			//	一致しているので「正解」と表示します。
			System.out.println("正解");
		}else {
			//	一致していないので「不正解」と表示します。
			System.out.println("不正解");
		}
	}
}




class Main {

	public static void main(String[] args) {

		//【問題】入力された文字からStringクラスのcharAtを使用して文字を抜き出して
		//結合して単語を作り、一致するかどうか判定するプログラムを完成させましょう。

		//入力された文字列を変数str1,str2,str3,str4とします。
		String str1 = "ぱんだ";
		String str2 = "みそしる";
		String str3 = "がっこう";
		String str4 = "ざぶとん";

		//上の文字列からcharAtを使ってn番目の文字を抜き出します。
		//StringクラスのcharAtを利用して0番目のchar値をchar型の変数char1に代入します。
		char char1 = str1.charAt(0);
		//★charAtを利用してstr2の1番目の値をchar型の変数char2に代入してみましょう。★
        char char2 = str2.charAt(1);
		//★charAtを利用してstr3の2番目の値をchar型の変数char3に代入してみましょう。★
        char char3 = str3.charAt(2);
		//★charAtを利用してstr4の3番目の値をchar型の変数char4に代入してみましょう。★
        char char4 = str4.charAt(3);

		//抜き出した文字列char1からchar4はchar型なので
		//StringクラスのvalueOfメソッドを使用して文字列型に変換します。       ★String型の変数.valueOf()
		String str5 = String.valueOf(char1);                                      ()内の数要素を文字列型に変換できる。
		String str6 = String.valueOf(char2);　　　　　　　　　　　　　　　　　　　今回の場合、charを文字列型に変換
		String str7 = String.valueOf(char3);
		String str8 = String.valueOf(char4);

		//文字列str5からstr8を結合してStringの変数resultに代入します。
		String result = str5 + str6 + str7 + str8;

		//★文字列resultが"ぱそこん"と一致するかどうかをequalメソッドを使って確認してみましょう。★
		if(result.equals("ぱそこん")) {                                           ???result == "ぱそこん"にすると、そのあとの結果が不正解になるのはなぜ?
			//文字列が一致したので変数resultと"正解！"を出力します。
			System.out.println(result);
			System.out.println("正解！");
		} else {
			//文字列が一致しなかったので変数resultと"不正解"を出力します。
			System.out.println(result);
			System.out.println("不正解");
		}

	}

}


String型変数.equals()


class Main {
	public static void main(String[] args) {

		//	【問題】左の画面では選んだ合同条件（文字列）から表示する三角形（画像）を変えています。
		//	このプログラムを文字列を用いて、再現してみましょう。
		//	ここでは画像は文字列で"imageA", "imageB","imageC"の3つを用意したとします。

		//	表示する画像を表す文字列を格納する変数「image」を用意します。
		String image = "";

		//	合同条件を格納する変数「congruence」を用意します。
		String congruence = "";

		//★String型の変数congruenceに合同条件を代入しましょう。
		//	ただし、合同条件は以下のいずれかを選んで代入してください。
		//	・3組の辺の長さがそれぞれ等しい
		//	・2組の辺の長さとその間の角がそれぞれ等しい
		//	・1組の辺の長さとその両端の角がそれぞれ等しい★
		congruence = "3組の辺の長さがそれぞれ等しい";

		//	「congruence」に格納されているものを判別して、対応する画像の文字列を表示しましょう。
		//	なお、対応する合同条件と画像は以下の通りとします。
		//	「3組の辺の長さがそれぞれ等しい」→「imageA」
		//	「2組の辺の長さとその間の角がそれぞれ等しい」→「imageB」
		//	「1組の辺の長さとその両端の角がそれぞれ等しい」→「imageC」

		//★「congruence」が「3組の辺の長さがそれぞれ等しい」と一致しているかどうか判定できるように以下のif文を埋めてみましょう。★
		if (congruence.equals("3組の辺の長さがそれぞれ等しい")) {
			//	一致しているので、imageに「imageA」を代入しました。
		    image = "imageA";

		    //★同様に残りの2つの条件についても判定できるようにelse if文を追加してみましょう。★
		}else if(congruence.equals("2組の辺の長さとその間の角がそれぞれ等しい")){
		    image = "imageB";
		}else if(congruence.equals("1組の辺の長さとその両端の角がそれぞれ等しい")){
		    image = "imageC";
		}

		//	表示する画像の文字列を表示します。
		System.out.println(image);

	}
}


Integer 
 数値を扱う参照型（範囲はint型とおなじ）
 
 class Main {

	public static void main(String[] args) {

		//【問題】N(ニュートン)、m(メートル)、j(ジュール)を用いて仕事の大きさを求めプログラムを完成させましょう。

		//初期値600のInteger型の変数gと、初期値1のInteger型の変数mを宣言します。
        Integer g = 600;
        Integer m = 1;

		//★Integer型の変数Nに、変数gを100で割った値を入れてみましょう。★
        Integer N = g / 100;

		//★Integer型の変数jにN*mの値を入れ、jを出力してみましょう。★
        Integer j = N*m;
        System.out.println(j);


	}

}



Integr.parseInt(文字列型の変数)
   文字型の数字の型の一つであるint型に変換できる
   別の変数に割り当てる際には、その変数のデータ型をint,Integer型で定義する
   ※「あ」「a」といった文字列型は変換不可
   
class Main {

	public static void main(String[] args) {

		//【問題】江戸時代が始まる年号をparseIntメソッドを使用して
		//Integer型に変換し、計算して出力するプログラムを作成しましょう。

		//千の位の任意の数値をString型の変数「thousands」に"1"を与えて初期化します。
		String thousands = "1";

		//百の位の任意の数値をString型の変数「hundreds」に"6"を与えて初期化します。
		String hundreds = "6";

		//十の位の3つの選択肢のうち、任意の数値をString型の変数「tens」に与えて初期化します。
		String tens = "0";

		//一の位の3つの選択肢のうち、任意の数値をString型の変数「first」に与えて初期化します。
		String first = "3";

		//IntegerクラスのparseIntメソッドを使用して
		//thousandsの値を変数名「numThousands」でInteger型に変換します。
		Integer numThousands = Integer.parseInt(thousands) * 1000;

		//IntegerクラスのparseIntメソッドを使用して
		//hundredsの値を変数名「numHundreds」でInteger型に変換してみましょう。★
		Integer numHundreds = Integer.parseInt(hundreds) * 100;

		//★IntegerクラスのparseIntメソッドを使用して
		//tensの値を変数名「numTens」でInteger型に変換してみましょう。★
        Integer numTens = Integer.parseInt(tens);

		//★IntegerクラスのparseIntメソッドを使用して
		//firstの値を変数名「numFirst」でInteger型に変換してみましょう。★
        Integer numFirst = Integer.parseInt(first);

		//★Integer型の変数ansYearにnumThousands, numHundreds, numTens ,numFirstの合計を代入しましょう。
        Integer ansYear = numThousands + numHundreds + numTens + numFirst;

		//★Integer型の変数ansYearを使用して
		//"江戸時代の開始は1603年"と表示させてみましょう。★
		System.out.println("江戸時代の開始は " + ansYear +  "年");

		//★numTensの値が0かつnumFirstの値が3であるか判定しましょう。
		//判定にはequalsメソッドを使用しましょう。★
		if(numTens == 0 && numFirst == 3) {
			//条件と一致していた場合は"正解！"と表示させます。
			System.out.println("正解！");
		}
	}

}


Integer.toString(数値型の変数);
  数値型をString型に変換する
  
class Main {

	public static void main(String[] args) {

		//【問題】大化の改新が起きた年を、二つの入力値から文字列結合して表示するプログラムを完成させましょう。


		//Integer型の変数num1とnum2を64と5を代入して宣言します。
		Integer num1 = 64;
		Integer num2 = 5;

		//★num1とnum2をtoStringを使用してString型に変換し、変数num3、num4に代入してみましょう。★
        String num3 = Integer.toString(num1);
        String num4 = Integer.toString(num2);

		//★変数num3とnum4を使用し、「645年：大化の改新」と出力するように文字列結合して記述してみましょう。★
        System.out.println(num3 + num4 + "年:大化の改新");
	}

}


Integer.valueOf(文字列型の変数)
  
  
class Trade {
	public static void main(String[] args) {
		String money = "10000";
		//★Integer型のcashにString型のmoneyをIntegerのvalueOfを用いてInteger型に変換した値を格納しましょう。
        Integer cash = Integer.valueOf(money);

		//double型のcoinにcoinを1以上6未満の値をランダムで取得する値で割ったdouble型の値を返すbuyメソッドの戻り値を格納します。 
		double coin = buy(cash);
		//double型のgainにcoinを1以上6未満の値をランダムで取得する値で割ったdouble型の値を返すsellメソッドの戻り値からcashの値を引いた値を格納します。
		double gain = sell(coin) - cash;
		//double型のgainをもとに出力するメッセージを変更します。
		massage(gain);
	}

	//double型の1以上6未満の値をランダムで取得した値をexchangeに格納、返すrandamDoubleメソッド。
	//exchangeの値の逆襲を小数点第2位まで出力して為替を出力。
	static double randomDouble(int num) {
		double exchange = (Math.random() * num) + 1;
		System.out.println("為替　：" + String.format("%.2f", 1/exchange) + "枚/円");
		return exchange;
	}
	//double型の1以上6未満の値をランダムで取得した値で割ることでcashをcoinに変換するbuyメソッド。
	//cashとcoinの値を出力。
	static  double buy(Integer cash) {
		double coin = cash / randomDouble(5);
		System.out.println("コイン："+ cash + "円 => " + (int)coin + "枚");
		return coin;
	}
	//double型の1以上6未満の値をランダムで取得した値でかけることでcoinをamount(お金)に変換するbuyメソッド。
	//amountとcoinの値を出力。
	static  double sell(double coin) {
		double amount =  coin * randomDouble(5);
		System.out.println("換金額：" + (int)coin + "枚 => " + (int)amount + "円");
		return amount;
	}
	//double型のgainをもとに出力するメッセージを変更します。
	//gainが0より大きい値か0以下かで値を出力する。
	static void massage(double gain) {
		System.out.println("--------------------------");
		if(0 < gain) {
			System.out.println("大儲け！！" + (int)gain + "円の利益");
		}else {
			System.out.println("散財！" + (int)gain + "円の損失");
		}
	}
}


null


class Main {

	public static void main(String[] args) {

		//【問題】入力された値がnullか1以上かを判定して炎の燃え方を出力するプログラムを完成させましょう。

		//Integer型の変数magicalPowerにnullもしくは、1以上の数を代入します。
		Integer magicalPower = null;

		//magicalPowerがnullの場合、「火が消える」と出力します。
		if(magicalPower == null) {
			System.out.println("火が消える");

		//★magicalPowerが20以下の場合、「火が小さく燃える」と出力してみましょう。★
		} else if (magicalPower <= 20) {
            System.out.println("火が小さく燃える");

		//★その他の場合、「火が大きく燃える」と出力してみましょう。★
		} else {
            System.out.println("火が大きく燃える");
		}

		//実行して確認後、変数magicalPowerに1以上の数値を与えて再度実行してみましょう。
	}

}
