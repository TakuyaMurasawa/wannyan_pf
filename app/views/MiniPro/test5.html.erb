final
 -変数、メソッド、クラスの前につけることにより、後に値の変換や継承をできないように出来る
　　ーfinal double tax = 0.1   ---X--->  tax = 0.5
　　
    -final void attak(){                                       void attak(){
             System.out.println("手で攻撃する");   ---X--->            System.out.println("手で攻撃する");
　　　　　　　　　　　　}                                                        }
　　　　　　　　　　　　
　　-final class oya {                                          class oya extends kodomo{
　　                                              ---X--->
　　             }                                                                   }
class Main{
    public static void main(String[] args){
        //【問題】円の面積を求めるプログラムを作成してみましょう。

        //★円周率を持たせるfinal修飾子を付けたdouble型の変数「pi」を初期値3.14で宣言してみましょう。★
        final double pi = 3.14;

        //円の半径を持たせるdouble型の変数「radius」を初期値5で宣言します。
        double radius = 5;

        //円の面積を持たせるdouble型の変数「area」を初期値０で宣言してみましょう。
        double area = 0;

        //★円の面積を「pi」「radius」を用いて求めて変数「area」に代入してみましょう。
        //ただし、円の面積は半径×半径×円周率で求められます。★
        area = radius * radius * pi;

        //円の面積を表示します。
        System.out.println(area);

        //実行して確認したら、radiusの値を0~10までの間で変更して試してみましょう。
    }
}



static 


class Main {
	public static void main(String[] args) {
		//【問題】以下のプログラムが正しく実行されるようにstaticを付けてみましょう。

		//String型の変数「answer」を宣言し、双子葉類を初期値として与えます。
		String answer = "双子葉類";

		//「Result」クラスをインスタンス化します。ただし、インスタンス名を「result」とします。
		Result result = new Result();

		//今回はアサガオの問題を想定してみます。
		//★「answer」が双子葉類と等しいかを判別できるように以下のif文を埋めてみましょう★
		if(answer.equals("双子葉類")) {
			System.out.println(Result.correct);
		}else {
			System.out.println(result.incorrect);
		}

	}
}

class Result {
	//★mainメソッドが正しく実行されるように、「correct」「incorrect」どちらか一方にだけstaticを書き加えてみましょう。
	static String correct = "正解";
	String incorrect = "不正解";
}



try~catch　　　　　　　　　　　　　　　　　　　　　　　　　 通常な処理を行っている途中で➀(今回の場合は繰り返し文の場合)　
基本構文  try{                                              例外な処理が起きた場合本来であればエラーが起きてしまうが
            int kotae = a / b;　　　　　　　　　　　　　　　事前にこのエラーが起きた時➁はこの処理をするとしておけば
             }catch(0で割ってしまうという例外){➁　　　　　　 エラーが起きた時システムエラーでなく、その処理の内容➂を実行することができる
               System.out.println("0では割れません");➂
                  }

class Main {
	public static void main(String[] args) {
		//	【問題】解答を配列に格納し、表示させようとしたときに発生する可能性のある例外を考えてみましょう。

		//	問題数を表すint型の変数「question」を宣言し、4を代入します。
		int question = 4;

		//	問題の解答をString型の配列「answer」に代入します。
		//	ただし、今回は例外を確認するため最初の三問のみ格納します。
		String[] answer = {"太宰治","谷崎潤一郎","川端康成"};

		//	例外が発生する可能性がある処理を行います。
		try {                                                                                  -----
                                                                                                    |
			//★問題数分処理を繰り返すように以下のfor文を正しく埋めてみましょう。                   | 
			//	ただし、カウンタ変数をiとし、初期値を0、変数「question」より小さいとします。★      |
			for(int i = 0;i<question;i++) {                                                         |  ➀
                                                                                                    |
				//	配列「answer」からインデックス番号がiの要素を表示します。                       |
				System.out.println(answer[i]);                                                      |
			}                                                                                  -----
			//★この処理では、配列の要素数より多く繰り返しているため
			//「ArrayIndexOutOfBoundsException」という例外が発生します。
			//キャッチできるように以下の空欄を埋めてみましょう
			//ただし引数は「eとします」★
		}catch(ArrayIndexOutOfBoundsException e) {    ➁
			System.out.println("例外が発生しました。");      ➂
		}
	}
}


class Main {
	public static void main(String[] args) {
		//	【問題】足し算・引き算・掛け算・割り算がそれぞれ０で実行できるか確認してみましょう。
		//			例で与えられた足し算と同じように、他の演算についても記述してみましょう。

		int i = 3;
		int result = 0;

		//	例）足し算
		try {
			//iと0を足し算して式と結果を出力しましょう。
			System.out.print(i + "+0=");
			result = i + 0;
			System.out.println(result);
		}catch(Exception e){
			//例外をキャッチした時は「実行できません」を表示しましょう。
			System.out.println("実行できません");
		}

		//	上記の例を参考に、他の演算についても記述してみましょう。
		//	コメント部分は書かなくてよいです。
		//★①引き算★
        try {
			System.out.print(i + "-0=");
			result = i - 0;
			System.out.println(result);
		}catch(Exception e){
			System.out.println("実行できません");
		}

		//★②掛け算★
        try {
			System.out.print(i + "*0=");
			result = i * 0;
			System.out.println(result);
		}catch(Exception e){
			System.out.println("実行できません");
		}

		//★③割り算★
        try {
			System.out.print(i + "/0=");
			result = i / 0;
			System.out.println(result);
		}catch(Exception e){
			System.out.println("実行できません");
		}

	}
}


class Main {

	public static void main(String[] args) {

		//【問題】20個の飴を入力された人数で分ける処理を行うとき、
		//人数に0人が入力された場合に例外処理を行うようプログラムを完成させましょう。

		//入力された人数をint型の変数numに入れて初期化します。
		int num = 0;

		//0除算が発生する可能性のある処理をtry内に記述します。
		//★tryで処理を囲ってみましょう。★
	 try{
			//int型の変数shoに飴の数20を変数numで割った結果を代入します。
			int sho = 20 / num;
			//★int型の変数amariに20を変数numで割った余りを代入してみましょう。★
            int amari = 20 % num;

			//変数shoとamariを出力します。
			System.out.println(sho);
			System.out.println(amari);

		//0除算が行われたときに、例外(ArithmeticException)を受け取り、catch内の処理が実行されます。
		//★catchを記述してみましょう。★
		}catch(Exception ex){
			//例外が発生した場合"0除算です。"を出力します。
			System.out.println("0除算です。");
		}
	}
}



起動引数


class Main {
	public static void main(String[] args) {
		//	【問題】起動引数に指定された月の昔の呼び方と、その由来を表示するプログラムを作成してみましょう。

		//★String型の「month」を宣言し、起動引数の先頭の要素を代入しましょう。★
		String month = "2";

		//	「month」の値によって実行する処理を変えるためにswitch文を使用します。
		//★以下の空欄を正しく埋めてみましょう。★
		switch(month) {
		//	1の場合
		case "1":
			System.out.println("睦月");
			System.out.println("正月に当たって親しみ睦み合って交誼を暖めるということからきた。");
			break;
			//	2の場合
		case "2":
			System.out.println("如月");
			System.out.println("寒くて更にきぬを着る、衣更着（きぬさらぎ）からきたという。");
			break;
			//	3の場合
		case "3":
			System.out.println("弥生");
			System.out.println("「草木弥生月」を略した言葉。「弥」は「いよいよ」「ますます」という意味があり、草木がいよいよ生い茂るという意味の「弥生」が変化した呼び名");
			break;
			//	4の場合
		case "4":
			System.out.println("卯月");
			System.out.println("ユキノシタ科の落葉低木「ウヅキ」の花である「卯の花」が咲くころの意味");
			break;
			//	5の場合
		case "5":
			System.out.println("皐月");
			System.out.println("田植えが始まる時期なので、「早苗を植える月」という意味から「早苗月」と呼ばれ、それが略されて「さつき」になったといわれている");
			break;
			//	6の場合
		case "6":
			System.out.println("水無月");
			System.out.println("旧暦では梅雨明けの残暑の頃となり、厳しい日照りが続いて水が枯れる月ということから「水無月」となった。");
			break;
			//	７の場合
		case "7":
			System.out.println("文月");
			System.out.println("短冊に歌や字を書く七夕の行事から「文披月（ふみひろげづき）」、稲穂が膨らむ月ということで「ふくみ月」、これらが転じて「文月」になったといわれている。");
			break;
        case "8":
			System.out.println("葉月");
			System.out.println("葉の落ちる月「葉落月（はおちづき）」が転じて「葉月」。現代感覚では葉が生い茂る様子を思い浮かべるが、旧暦では7月から秋となるため、秋真っ盛りだった。");
			break;
		case "9":
			System.out.println("長月");
			System.out.println("秋の夜長を意味する「夜長月（よながづき）」の略で「長月」になった。また、秋の長雨の「長雨月（ながめづき）」、稲穂が実る「穂長月（ほながづき）」からという説も。");
			break;
		case "10":
			System.out.println("神無月");
			System.out.println("神々が出雲の国に行ってしまい留守になるという意の「神なき月」が転訛して「神無月」。神々が集まる出雲の国では、「神在月（かみありつき）」という。");
			break;
		case "11":
			System.out.println("霜月");
			System.out.println("文字通り霜が降る月という意の「霜降月（しもふりつき）」の略で「霜月」となった。");
			break;
		case "12":
			System.out.println("師走");
			System.out.println("12月は僧（師）を迎えてお経を読んでもらう月だった。師が馳せる月という意の「師馳す」が転訛し、走るという字があてられるようになった。");
			break;	
		}

		//★起動引数に「1」～「12」までの好きな数字を指定して実行してみましょう。★
	}
}



import java.util.Random;

class Main {
	public static void main(String[] args) {
		//	【問題】起動引数に元素名を入れ、ランダムで指定されたものが何に利用されているかを表示するプログラムを句作ってみましょう。

		//	Randomクラスをインスタンス化します。
		Random random = new Random();

		//	int型の変数「no」にランダムで0~9までを発生させて代入します。
		//★以下の（）に正しい数値を埋めてみましょう。★
		int no = random.nextInt(9);
		//★String型の変数「name」を宣言し、起動引数(no + 1)番目の要素を代入してみましょう。★
		String name = args[no];

		//	選択された元素を表示します。
		System.out.println(name);

		//	「name」の値によって、実行する処理を分けるためにswitch文を利用します。
		//★以下の空欄を正しく埋めてみましょう。★
		switch(name) {
		//	水素の場合
		case "水素":
			System.out.println("ロケットの発射");
			break;
			//	ヘリウムの場合
		case "ヘリウム":
			System.out.println("風船");
			break;
			//	リチウムの場合
		case "リチウム":
			System.out.println("リチウムイオン電池");
			break;
			//	ベリリウムの場合
		case "ベリリウム":
			System.out.println("強力なばね");
			break;
			//	ホウ素の場合
		case "ホウ素":
			System.out.println("耐熱ガラス");
			break;
			//★以上の例を参考にして、「炭素」「窒素」「酸素」「フッ素」「ネオン」の場合も書いてみましょう。★
			//	ただしそれぞれの利用例は以下の通りです。
			//	炭素→鉛筆
			//	窒素→肥料
			//	酸素→医療用吸入器
			//	フッ素→歯のコーティング
			//	ネオン→ネオンサイン
		case "炭素":
			System.out.println("鉛筆");
			break;
		case "窒素":
			System.out.println("肥料");
			break;
		case "酸素":
			System.out.println("医療用吸入器");
			break;
		case "フッ素":
			System.out.println("歯のコーティング");
			break;
		case "ネオン":
			System.out.println("ネオンサイン");
			break;	
		}
		//★起動引数に「水素 ヘリウム リチウム ベリリウム ホウ素 炭素 窒素 酸素 フッ素 ネオン」を指定して実行してみましょう。★
		
		args[0] = "水素";
		args[1] = "ヘリウム";
		args[2] = "リチウム";
		args[3] = "ベリリウム";
		args[4] = "ホウ素";
		args[5] = "炭素";
		args[6] = "窒素";
		args[7] = "酸素";
		args[8] = "フッ素";
		args[9] = "ネオン";
		
	}
}



String class


import java.util.Random;

class Main {
	public static void main(String[] args) {
		//	【問題】ことわざの前半を格納する配列と、後半を格納する配列をそれぞれ用意しましょう。
		//	ランダムで要素を一つずつ取り出し、結合して表示してみましょう。

		//前半の配列を作成します。
		String[] first = {"弘法も","かわいい子には","柳に","火のないところに"};

		//続いて後半の配列を作成しましょう。
		String[] latter = {"旅をさせよ","筆の誤り","煙は立たぬ","雪折れなし"};

		Random random = new Random();

		//String型の変数「zenhan」にランダムで配列「first」から取り出した要素を格納します。
		String zenhan = first[random.nextInt(4)];

		//String型の変数「kouhan」にランダムで配列「latter」から取り出した要素を格納します。
		String kouhan = latter[random.nextInt(4)];

		//★String型の変数「result」に「zenhan」と「kouhan」を接合させて代入しましょう。★
		String result = zenhan + kouhan;

		//★「result」を表示してみましょう。★
		System.out.println(result);
	}
}




String型変数.length()
  String型変数内の文字列の数を求めるメソッド(メソッドの為、最後に()を付けなければならない)

class Main {
	public static void main(String[] args) {
		//【問題】上五・中七・下五それぞれの文字数を確認し、字余り・字足らずを判定するプログラムを作成してみましょう。

		//	String型の変数「kami」「naka」「simo」にそれぞれ上五・中七・下五の文字列を格納します。
		String kami = "たびにやんで";
		String naka = "ゆめはかれのを";
		String simo = "かけめぐる";

		//「kami」の文字数が5より多い、または「naka」の文字数が7より多い、または「simo」の文字数が5より多いかどうかを判定し
		//その条件を満たす場合「字余りです」と表示するif文を作成しました。
		if(kami.length() > 5 || naka.length() > 7 || simo.length() > 5) {
			System.out.println("字余りです。");
		}

		//★「kami」の文字数が5より少ない、または「naka」の文字数が7より少ない、または「simo」の文字数が5より少ないかどうかを
		//判定できるように以下のif文を、上記のif文を参考に埋めてみましょう。★
		if(kami.length()<5 || naka.length()<7 || simo.length()<5) {
			System.out.println("字足らずです。");
		}
	}
}



String型変数.charAt()
   文字列の中から指定した1文字(char)を抜き出す際に利用
   順番は配列と同じで0～始まり、文字列の数以上に記載するとエラーになる
   
class Main {
	public static void main(String[] args) {
		//	【問題】用意した多項式の同類項の数を数えるプログラムを作成してみましょう。

		//	まず、変数「numericalExpression」に多項式を用意しました。
		String numericalExpression = "x+2+y+3x+5";

		//	「numericalExpression」にxの項が何回出てくるかを数えてみます。
		//	まず、何回出てきたかカウントするための変数「count」を用意します。
		int count = 0;

		//	比較するための答え「answer」を用意します。
		int answer = 2;

		//★for文を「numericalExpression」の文字数分繰り返すように正しく埋めてみましょう。
		//	ただしカウンタ変数をi、初期値を0として、length()メソッドを利用しましょう。★
		
		for(int i = 0;i < numericalExpression.length();i++) 
		
			//★charAtメソッドを利用して、i文字目が「x」と一致しているかどうか判断できるように以下のif文を埋めてみましょう。★
			if(numericalExpression.charAt(i) == 'x') {　　　　　　　　　　　　　　　　　　　　　　　★charなので''シングルクォーテーションで囲む
			
				//★一致しているのでインクリメント演算子を利用して、countの値を増やしてみましょう。★
                   count++;
			}
		}
		
		
		//	求めた「count」を表示します。
		System.out.print(count + "：");

		//★「count」と「answer」が一致しているか判定できるように以下のif文を埋めてみましょう。★
		if(count == answer) {
			//	一致しているので「正解」と表示します。
			System.out.println("正解");
		}else {
			//	一致していないので「不正解」と表示します。
			System.out.println("不正解");
		}
	}
}
